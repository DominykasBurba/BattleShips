@using BattleShips.Domain
@using BattleShips.Domain.Cells
@using BattleShips.Domain.Proxy
@using BattleShips.Domain.Flyweight
@using BattleShips.Services
@inject GameService Game

<div class="board-frame">
    <div class="board-with-labels">
        <!-- Column headers (A, B, C, etc.) -->
        <div class="column-labels" style="--size:@Board.Size; --cell:34px">
            <div class="label-cell"></div> <!-- Empty corner cell -->
            @for (int c = 0; c < Board.Size; c++)
            {
                <div class="label-cell">@((char)('A' + c))</div>
            }
        </div>
        
        <!-- Board rows with row numbers -->
        @for (int r = 0; r < Board.Size; r++)
        {
            <div class="board-row" style="--size:@Board.Size; --cell:34px">
                <!-- Row number -->
                <div class="label-cell">@(r + 1)</div>
                
                <!-- Board cells -->
                @for (int c = 0; c < Board.Size; c++)
                {
                    var rr = r;
                    var cc = c;

                    var cell = Board[rr, cc];

                    // Use Flyweight pattern: Get shared appearance object instead of computing each time
                    var skin = (Own && cell.Ship != null) ? cell.Ship.Skin : (ShipSkin?)null;
                    var appearance = CellAppearanceFactory.Instance.GetAppearance(cell.Status, Own, skin);

                    <CellView CssClass="@appearance.CssClass"
                              Text="@appearance.DisplayText"
                              OnClick="@(() => Click(rr, cc))" />
                }
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public IBoardView Board { get; set; } = default!;
    [Parameter] public bool Own { get; set; }
    [Parameter] public bool Interactable { get; set; } = true;
    [Parameter] public Func<Position, Task>? OnFire { get; set; }

    private Task Click(int r, int c)
    {
        if (!Interactable || Own || OnFire is null) return Task.CompletedTask;

        var cell = Board[r, c];

        // â›” block re-clicking a tried cell (hit/miss/sunk)
        // BUT allow re-shooting Shielded cells to break the shield
        if (cell.IsRevealed && cell.Status != CellStatus.Shielded) return Task.CompletedTask;

        return OnFire(new Position(r, c));
    }

    // Old methods replaced by Flyweight pattern (CellAppearanceFactory)
    // CellCss and CellText logic now handled by shared flyweight objects
}